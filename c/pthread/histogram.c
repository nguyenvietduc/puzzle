/* Lab 1: Histrogram generation 
 * compile as follows: gcc -o histogram histogram.c -std=c99 -lpthread -lm
 */
#include <stdlib.h>
#include <stdio.h>
#include <sys/time.h>
#include <math.h>
#include <float.h>
#include <pthread.h>
#include <semaphore.h>

void run_test(int,int);
void compute_gold(int *, int *, int, int);
void compute_using_pthreads(int *, int *, int, int, int);
void check_histogram(int *, int, int);
void* pthread_mapreduce(void*);

#define HISTOGRAM_SIZE 500
#define NUM_THREADS 8

pthread_mutex_t mutex;
sem_t sem;

// struct for list of arguments to be passed to pthread function
typedef struct thread_args {
	int thread_id;
	int chunk_size;
	int* starting_element;
	int* histogram;
	int* buffer;
} thread_args;

////////////////////////////////////////////////////////////////////////////////
// Program main
////////////////////////////////////////////////////////////////////////////////
int  main( int argc, char** argv) 
{
	if(argc < 2 || argc > 3){
		printf("Usage: histogram <num elements> [num_threads]\n");
		exit(0);
	}

	int num_elements = atoi(argv[1]);
	int num_threads = NUM_THREADS;
	

	if (argc == 3)
		num_threads = atoi(argv[2]);

	run_test(num_elements, num_threads);

	return 0;
}

////////////////////////////////////////////////////////////////////////////////
//! Generate the histogram on Single Threaded CPU and Then PTHREADS and Check for Correctness
///////////////////////////////////////////////////////////my_args/////////////////////
void run_test(int num_elements, int num_threads) 
{
	float diff;
	int i; 
	int *reference_histogram = (int *)malloc(sizeof(int) * HISTOGRAM_SIZE); // Space to store histogram generated by the CPU
	int *histogram_using_pthreads = (int *)malloc(sizeof(int) * HISTOGRAM_SIZE); // Space to store histogram generated by the GPU

	// Allocate memory for the input data
	int size = sizeof(int) * num_elements;
	int *input_data = (int *)malloc(size);
	
	// Randomly generate input data. Initialize the input data to be integer values between 0 and (HISTOGRAM_SIZE - 1)
	srand(time(NULL)); // add this for real randomness
	for(i = 0; i < num_elements; i++)
		input_data[i] = floorf((HISTOGRAM_SIZE - 1) * (rand()/(float)RAND_MAX));

	printf("Creating the reference histogram. \n"); 
	// Compute the reference solution on the CPU
	struct timeval start, stop;	
	gettimeofday(&start, NULL);

	compute_gold(input_data, reference_histogram, num_elements, HISTOGRAM_SIZE);

	gettimeofday(&stop, NULL);
	printf("CPU run time = %0.10f s. \n", (float)(stop.tv_sec - start.tv_sec + (stop.tv_usec - start.tv_usec)/(float)1000000));
	// check_histogram(reference_histogram, num_elements, HISTOGRAM_SIZE);
	
	// Compute the histogram using pthreads. The result histogram should be stored on the histogram_using_pthreads array
	printf("\n");
	printf("Creating histogram using pthreads. \n");

	struct timeval pstart, pstop;	
	gettimeofday(&pstart, NULL);
	compute_using_pthreads(input_data, histogram_using_pthreads, num_elements, num_threads, HISTOGRAM_SIZE);
	gettimeofday(&pstop, NULL);
	printf("Pthreads run time = %0.10f s. \n", (float)(pstop.tv_sec - pstart.tv_sec + (pstop.tv_usec - pstart.tv_usec)/(float)1000000));
	// check_histogram(histogram_using_pthreads, num_elements, HISTOGRAM_SIZE);

	// Compute the differences between the reference and pthread results
	diff = 0.0;
   for(i = 0; i < HISTOGRAM_SIZE; i++)
		diff = diff + abs(reference_histogram[i] - histogram_using_pthreads[i]);

	printf("Difference between the reference and pthread results: %f. \n", diff);
   
	// cleanup memory
	free(input_data);
	free(reference_histogram);
	free(histogram_using_pthreads);
	pthread_mutex_destroy(&mutex);

	pthread_exit(NULL);
}

/* This function computes the reference solution. */
void compute_gold(int *input_data, int *histogram, int num_elements, int histogram_size)
{
  int i;
  
  // Initialize histogram
  for(i = 0; i < histogram_size; i++) 
			 histogram[i] = 0; 

  // Bin the elements in the input stream
  for(i = 0; i < num_elements; i++)
			 histogram[input_data[i]]++;
}


// Write the function to compute the histogram using pthreads
void compute_using_pthreads(int *input_data, int *histogram, int num_elements, int num_threads, int histogram_size)
{
	int chunk_size;			// number of elements processed by a thread
	int left_over;
	thread_args* args;		// thread arguments to be passed to thread function
	pthread_t* threads;		// thread handles
	int** buffer;

	int i, thread_id;

	// Allocate mempory for thread handles
	threads = (pthread_t*)malloc(sizeof(pthread_t)*num_threads);

	// Allocate histogram buffer for each thread
	buffer = (int**)malloc(num_threads*sizeof(int*));
	for (i=0; i<num_threads; ++i)
		buffer[i] = (int*)malloc(HISTOGRAM_SIZE*sizeof(int));

	// init mutex/binary semaphore for histogram
	pthread_mutex_init(&mutex, NULL);
	sem_init(&sem, 0, 1);

	// Init histogram
	for(i=0; i<histogram_size; ++i)
		histogram[i]=0;

	for(i=0; i<num_threads; ++i)
		for(int j=0; j<HISTOGRAM_SIZE;++j)
			buffer[i][j] = 0;

	// calculate chunk_size
	left_over = num_elements % num_threads;
	chunk_size = (num_elements-left_over) / num_threads;

	// thread creation
	for(thread_id=0; thread_id<num_threads; ++thread_id) {
		// allocate new thread_args for each thread
		args = (thread_args*)malloc(sizeof(thread_args));

		// populate it
		args->thread_id 		= thread_id;
		args->chunk_size 		= chunk_size;
		args->histogram 		= histogram;
		args->starting_element	= input_data + chunk_size*thread_id;
		args->buffer 			= buffer[thread_id];

		// there may be some leftover elements at the end of input_data array
		// let thread (num_threads-1) handles it
		if (thread_id==(num_threads-1))
			args->chunk_size += left_over;

		pthread_create(&threads[thread_id], NULL, pthread_mapreduce, (void*)args);
	}

	for(thread_id=0; thread_id<num_threads;++thread_id)
		pthread_join(threads[thread_id],NULL);

	free(threads);
	free(args);
}

void* pthread_mapreduce(void* args) {
	thread_args* my_args = (thread_args*)args;
	int i;

	// TODO use hash table instead of array

	i = 0;
	while(i < my_args->chunk_size) {
		my_args->buffer[my_args->starting_element[i]]++;
		i++;
	}

	pthread_mutex_lock(&mutex);
	//sem_wait(&sem);
	for (i=0; i<HISTOGRAM_SIZE;++i)
		my_args->histogram[i] += my_args->buffer[i];
	pthread_mutex_unlock(&mutex);
	//sem_post(&sem);

	pthread_exit(0);
}


/* we are currently not using this function but you are welcome to try it */
void check_histogram(int *histogram, int num_elements, int histogram_size)
{
	int sum = 0;
	for(int i = 0; i < histogram_size; i++)
		sum += histogram[i];

	printf("Number of histogram entries = %d. \n", sum);
	if(sum == num_elements)
		printf("Histogram generated successfully. \n");
	else
		printf("Error generating histogram. \n");
}